<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.39">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Findings – MUSA 550</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-9ea0a49c779b6fc496fdb60b6bf00fef.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-b6df0406b0713591b2f156d6d5373836.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">MUSA 550</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./home.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./thoughts.html"> 
<span class="menu-text">Thoughts</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./analysis/Final_project.html"> 
<span class="menu-text">Analysis</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="./findings.html" aria-current="page"> 
<span class="menu-text">Findings</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./faq.html"> 
<span class="menu-text">FAQ</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/MUSA-550-Fall-2024/"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./#"> 
<span class="menu-text">Forest loss since you opened this page: <span id="navbar-total-acres">0</span> acres</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content column-page" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Findings</h1>
</div>



<div class="quarto-title-meta column-page">

    
  
    
  </div>
  


</header>


<style>
  .parallax-container {
    position: relative;
    overflow: hidden;
    height: 500px; /* Adjust height as desired */
  }

  .parallax-video-container {
    position: absolute;
    top: 0;
    left: 0;
    height: 100%; /* Ensures it fills the container */
    width: 100%; /* Ensures it fills the container */
    object-fit: cover; /* Ensures video scales properly */
    z-index: -1; /* Keeps it behind other content */
  }
</style>
<!-- Parallax Section -->
<div class="parallax-container">
<p><video class="parallax-video-container" autoplay="" muted="" loop=""> <source src="images/defo.mp4" type="video/mp4"> Your browser does not support the video tag. </video></p>
</div>
<div style="display: flex; gap: 10px; align-items: flex-start; flex-direction: column;">
<div style="display: flex; gap: 10px; align-items: flex-start;">
<div>
<div style="text-align: right; font-size: 12px; margin: 10px;">
<p>©Video by Desra</p>
</div>
<div style="display: flex; gap: 10px; align-items: flex-start; flex-direction: column;">
<div style="display: flex; gap: 10px; align-items: flex-start;">
<div>
<div style="border: 1px solid #ccc; padding: 15px; border-radius: 5px;">
<strong>Main findings focused on Feature Importance.</strong><br>
<br>
Brazil, subsidies and other transfers, and agricultural land were the most significant contributors to deforestation among all variables.<br>
<br>

<center>
<img src="images/visualization.svg" alt="Visualization" style="width: 70%; border-radius: 5px; margin-top: 20px;">
</center>
<p><br>
In the Random Forest analysis, the feature “Country_Brazil” has high importance, not simply because Brazil has a large forest area, but because its deforestation trends are highly variable and strongly influenced by other factors like agricultural subsidies, political policies, and enforcement of conservation laws. For instance, Brazil experienced a deforestation peak in 2004 when 27,772 km² of forests were cleared (equivalent to the size of Massachusetts), followed by a decline during years with stricter policies (Silva Junior et al.&nbsp;2021). This variability in deforestation rates makes Brazil-specific data critical in understanding global deforestation trends. Similarly, countries like Paraguay and Tanzania also rank highly due to their distinct patterns, such as agricultural expansion or population pressures, which uniquely influence their forest loss dynamics.<br>
<br>
By defintion, Subsidies and Other Transfers benefits include all unrequited, nonrepayable transfers on current account to private and public enterprises; grants to foreign governments, international organizations, and other government units; and social security, social assistance benefits, and employer social benefits in cash and in kind. According to Amaglobeli et al.&nbsp;(2024), Agricultural producer subsidies are prevalent, large, and deployed to achieve diverse and, at times, overlapping policy objectives. Among countries accounting for 90 percent of global GDP, food and agriculture subsidies amount to 0.3–0.7 percent of GDP over the past decade and a half. As highlighted by Damania et al.&nbsp;(2023), highlighted inefficiency of agricultural and timber subsidies. Between 2016 and 2018, $635 billion per year (equals approximately 0.9 percent of GDP and nearly one-fifth of agricultural value added for these countries) was given as support to agriculture in 84 countries. 71% of this support went directly to farmers or producers, mainly in ways that encouraged them to produce more or use certain inputs, which can influence their decisions on what and how much to produce. This type of support often encourage unsustainable practices, such as excessive use of chemical fertilizers and pesticides, which lead to greenhouse gas emissions, land degradation, and biodiversity loss. Similarly, timber subsidies contribute to overharvesting, illegal logging, and forest degradation. They distort markets by making sustainable forest management less competitive than subsidized, unsustainable logging.<br>
<br>
The feature Agricultural Land (sq. km) emerges as one of the most significant contributors to deforestation in the feature importance analysis. This result is in line with finding from Hosonuma et al.&nbsp;(2012). Commercial agriculture is the most important driver of deforestation, followed by subsistence agriculture. Their study showed agriculture alone causes 73% of all deforestation. 40% of deforestation and most prominent in the early-transition phase. The other important land use is local/subsistence agriculture, which is related to 33% of deforestation.<br>
<br>
Other factors that stand out in the analysis are governance and economic indicators, which reveal intriguing relationships with deforestation. For instance, control of corruption shows a notable connection to deforestation, suggesting that governance quality significantly influences how natural resources are managed. In regions with poor governance and high corruption, illegal logging, weak enforcement of environmental regulations, and unsustainable land-use practices are more prevalent, exacerbating deforestation rates. Conversely, better governance often correlates with stronger protections and more sustainable practices.<br>
<br>
Another compelling factor is debt service on external debt, which indicates the economic pressures faced by nations. When a country allocates a significant portion of its resources toward debt repayment, it may prioritize short-term economic gains, such as expanding agricultural exports or extracting natural resources, to generate revenue. This often results in deforestation as forests are cleared to make way for cash crops or logging operations. Together, these governance and economic factors underline the complex, interconnected pressures that drive deforestation, pointing to the need for policies that address systemic issues like corruption and economic vulnerability to protect forests effectively.<br>
<br>
</p>
</div>
<br>

<div style="border: 2px solid #005f73; padding: 20px; background-color: #f0f9ff; border-radius: 8px; margin: 20px 0;">
<strong>Contemplation</strong><br>
<br>
Over time, the theory of deforestation has evolved, moving from simplistic explanations centered on population growth and agricultural expansion to more nuanced, multidimensional frameworks. Earlier models, like those discussed by Angelsen and Kaimowitz (1999), focused on economic drivers and agent-based decision-making, emphasizing variables such as land-use choices, macroeconomic pressures, and policy instruments. Recent research has expanded these perspectives by incorporating the roles of governance, global trade, climate change, and spatial dynamics. Studies now recognize deforestation as a complex phenomenon influenced by intertwined local and global factors, such as subsidies driving unsustainable agricultural practices, corruption weakening forest protections, and international markets shaping land-use patterns. This evolution reflects a shift toward systems-level thinking, which integrates biophysical, socioeconomic, and governance dimensions. Thus, while foundational theories remain relevant, contemporary approaches offer a deeper, more holistic understanding of deforestation, better equipping policymakers to address its underlying and immediate causes in an increasingly interconnected world.<br>
<br>
<br>

<p style="text-align: right; font-style: italic;">
What we are doing to the forests of the world is but a mirror reflection of what we are doing to ourselves and to one another.<br> <strong>~ Mahatma Gandhi</strong>
</p>
</div>
<br>

<div style="border: 1px solid #ccc; padding: 15px; border-radius: 5px;">
<p><strong>Additional discussions</strong><br>
<br>
<strong>Prediction</strong><br>
Although my analysis included predicting deforestation using socioeconomic factors with a Random Forest model, I believe that relying solely on these factors for such predictions may lack a solid logical foundation. Socioeconomic variables, while insightful, typically act as indirect drivers or proxies rather than immediate causes of deforestation. This perspective aligns with the framework proposed by Angelsen and Kaimowitz (1999), my main reference, which emphasizes the importance of analyzing deforestation through a more comprehensive approach. Their framework suggests considering the magnitude and location of deforestation, the agents involved, the variables influencing their choices, the decision parameters of these agents, as well as macroeconomic variables and policy instruments. A logical approach, as outlined in their work, involves understanding deforestation at three interconnected levels: sources, immediate causes, and underlying causes. By focusing only on socioeconomic factors, key dimensions such as the direct actions of deforestation agents (e.g., farmers or loggers), the biophysical constraints, and the specific policy environment might be overlooked.<br>
<br>
<strong>Optimization</strong><br>
The initial Random Forest model achieved an R² score of 0.67 on the testing dataset, indicating that 67% of the variance in the target variable was explained by the model. Using 3-fold cross-validation, the R² scores varied between 0.85, 0.71, and 0.56, with an average score of 0.71 and a standard deviation of 0.12, highlighting moderate variability in model performance across different folds. After optimizing the model using GridSearchCV, the testing R² score remained unchanged at 0.67. However, the 3-fold cross-validation scores showed slight improvement, with individual scores of 0.86, 0.74, and 0.56. This resulted in an increased average cross-validation score of 0.72, while the standard deviation remained at 0.12.<br>
</p>
</div>
<br>

<div style="border: 1px solid #ccc; padding: 15px; border-radius: 5px;">
<p><strong>References</strong><br>
<br>
Amaglobeli, D. (2024). Agricultural producer subsidies. IMF Notes, 2024(002), 1. <a href="https://doi.org/10.5089/9798400285950.068">https://doi.org/10.5089/9798400285950.068</a>.<br>
<br>
Angelsen, A., &amp; Kaimowitz, D. (1999). Rethinking the Causes of Deforestation: Lessons from Economic Models. The World Bank Research Observer, 14(1), 73–98. <a href="https://doi.org/10.1093/wbro/14.1.73">https://doi.org/10.1093/wbro/14.1.73</a>.<br>
<br>
Damania, R., Balseca, E., De Fontaubert, C., Gill, J., Kim, K., Rentschler, J., Russ, J., &amp; Zaveri, E. (2023). Detox development. <a href="https://doi.org/10.1596/978-1-4648-1916-2">https://doi.org/10.1596/978-1-4648-1916-2</a>.<br>
<br>
Hosonuma, N., Herold, M., De Sy, V., De Fries, R. S., Brockhaus, M., Verchot, L., Angelsen, A., &amp; Romijn, E. (2012). An assessment of deforestation and forest degradation drivers in developing countries. Environmental Research Letters, 7(4), 044009. <a href="https://doi.org/10.1088/1748-9326/7/4/044009">https://doi.org/10.1088/1748-9326/7/4/044009</a>.<br>
<br>
Silva Junior, C. H. L., Pessôa, A. C. M., Carvalho, N. S., et al.&nbsp;(2021). The Brazilian Amazon deforestation rate in 2020 is the greatest of the decade. Nature Ecology &amp; Evolution, 5(2), 144–145. <a href="https://doi.org/10.1038/s41559-020-01368-x">https://doi.org/10.1038/s41559-020-01368-x</a>.<br>
</p>
</div>
</div>


</div>
</div>
</div>
</div>
</div>

</main> <!-- /main -->
<script>
  document.addEventListener("DOMContentLoaded", () => {
  console.log("Script loaded and DOM is ready");


  // Constants
  const acresPerField = 1.32; // Average size of a football field in acres
  const countdownDuration = 7; // Duration of the countdown in seconds
  const circleCircumference = 2 * Math.PI * 60; // Circumference of the progress circle (r = 60)

  // Retrieve stored values or initialize them
  let startTime = localStorage.getItem("startTime");
  let totalFieldsLost = localStorage.getItem("totalFieldsLost")
    ? parseInt(localStorage.getItem("totalFieldsLost"))
    : 0;

  if (!startTime) {
    startTime = Date.now();
    localStorage.setItem("startTime", startTime);
  }

  // Function to update the display based on elapsed time
  function updateDisplay() {
    const now = Date.now();
    const elapsedSeconds = Math.floor((now - startTime) / 1000);

    // Calculate fields lost
    const fieldsLost = Math.floor(elapsedSeconds / countdownDuration);
    totalFieldsLost = fieldsLost;

    // Calculate acres lost
    const totalAcresLost = (totalFieldsLost * acresPerField).toFixed(2);

    // Update total acres on the page
    const totalAcresElement = document.getElementById("total-acres");
    if (totalAcresElement) {
      totalAcresElement.textContent = totalAcresLost;
    }

    // Update navbar total acres
    const navbarTotalAcres = document.getElementById("navbar-total-acres");
    if (navbarTotalAcres) {
      navbarTotalAcres.textContent = totalAcresLost;
    }

    // Update the countdown timer
    const countdownValue = countdownDuration - (elapsedSeconds % (countdownDuration));
    const timerElement = document.getElementById("timer");
    if (timerElement) {
      timerElement.textContent = countdownValue-1;
    }

    // Update the circular progress bar
    const progressElement = document.getElementById("progress");
    if (progressElement) {
      
      if (countdownValue === countdownDuration) {
        // If the countdown just reset, immediately switch the bar to gray
        progressElement.style.transition = "none"; // Disable transition
        progressElement.style.strokeDashoffset = circleCircumference; // Full gray circle
        progressElement.style.stroke = "#ccc"; // Gray color
      } else {
        const progressOffset = (circleCircumference*(countdownValue-1)) / countdownDuration;
        progressElement.style.transition = "stroke-dashoffset 1s linear"; // Re-enable smooth transition
        progressElement.style.strokeDashoffset = progressOffset;
        progressElement.style.stroke = "#007bff"; // Blue color
    }}
    // Save updated fields lost to localStorage
    localStorage.setItem("totalFieldsLost", totalFieldsLost);
  }

  // Update the display every second
  updateDisplay();
  setInterval(updateDisplay, 1000);
  })
  </script>
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>